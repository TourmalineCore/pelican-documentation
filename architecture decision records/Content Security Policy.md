# Content Security Policy

#### Статус
Принято

## Контекст
Content Security Policy (CSP) — это механизм защиты, реализуемый через HTTP-заголовок Content-Security-Policy. Он позволяет указать, какие источники контента разрешены на странице. Это помогает предотвратить ряд атак, таких как XSS (Cross-Site Scripting), инъекции кода и загрузки вредоносных ресурсов.  

#### Цель CSP:
- Запретить выполнение инлайн-скриптов

- Запретить загрузку ресурсов (скриптов, стилей, изображений и т.д.) с неразрешенных источников

- Обеспечить доверенность загружаемого контента, контролируя источники каждого типа ресурса

#### Основные директивы:
- **default-src** — источник по умолчанию для всех типов ресурсов, кроме base-uri, frame-ancestors и form-action

- **script-src** — источники для выполнения скриптов

- **style-src** — источники для загрузки стилей

- **connect-src, img-src, font-src, media-src, frame-src и др.** — аналогично, но для других типов контента

#### Допустимые значения:
- 'self' — только с текущего домена

- 'none' — запретить полностью

- 'unsafe-inline', 'unsafe-eval' — разрешить инлайн-JS или [eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) (небезопасно)

- конкретные URL или схемы (https:)

Во время разработки и настройки CSP хорошей практикой считается использование заголовка Content-Security-Policy-Report-Only вместо Content-Security-Policy, чтобы отлавливать нарушения и понять, что ещё работает небезопасно, прежде чем включать жёсткую политику с блокировкой контента.

Основной проблемой в CSP-репорте являлось использование небезопасных значений:
- 'unsafe-inline' — разрешает любые встроенные скрипты и стили

- 'unsafe-eval' — разрешает eval()

Избавиться от этих директив можно, только если отказаться от инлайн-элементов, но они присутствуют в HTML и необходимы для корректной работы некоторых компонентов.

## Решение
Самое распространненое и эффективное решение — внедрение nonce или hash:
- nonce — уникальный код, генерируемый на каждый запрос к странице, добавляется в заголовок и на элементы на странице

- hash — хэш содержимого скрипта, если он не меняется

Случай с хешем нам не подходит, потому что у нас есть скрипт метрики, который меняется в зависимости от переменных. Для нашего кейса идеальным стало использование **nonce**. 

Суть в том, что только элементы с корректным nonce будут выполнены — злоумышленник не сможет предугадать/подделать значение.
Столкнулись с проблемой, которая заключалась в том, что мы задаем заголовки CSP на уровне next.config.js, то есть на этапе сборки, а nonce должен быть динамическим — разным на каждый запрос.

Мы добавили файл middleware.ts в src/, реализующий динамическую генерацию nonce и установку CSP-заголовка. Пример реализации взят из:
- [официальной документации Next.js](https://nextjs.org/docs/app/guides/content-security-policy)
- [доклада на конференции React Summit](https://gitnation.com/contents/content-security-policy-with-nextjs-leveling-up-your-websites-security/video)

Этот middleware:
1) генерирует nonce
2) вставляет его в CSP-заголовок
3) передает его через Request Headers
4) доступен в компонентах для использования в скриптах и стилях

Далее мы внедрили сгенерированный **nonce** в теги скриптов и стилей, встроенных в HTML в файле _document.tsx
После этого удалили значения 'unsafe-inline' и 'unsafe-eval', но по советам Lighthouse и документации пришлось оставить значение 'unsafe-inline' для script-src в прод версии, на случай, если устаревшие браузеры не будут поддерживать подход с nonce и без него элементы не смогут отобразиться. В современных браузерах **unsafe-inline**, прописанная рядом с  **nonce** вместе со **strict-dynamic**, игнорируется и не создает дыр в безопасности. 

После устранения проблем из отчета Content-Security-Policy-Report-Only мы перешли на хэдер Content-Security-Policy.

## Альтернативы
Использовать только статические hash для инлайн-скриптов

### Плюсы:
- Нет необходимости в middleware

- Простой конфиг

### Минусы:
Не подходит для динамического контента

## Последствия
- CSP влияет на внешние библиотеки: сторонние скрипты, виджеты могут перестать работать, если их явно не разрешить

- Требуется дополнительная поддержка при изменении структуры HTML или появлении новых инлайн-элементов

## Плюсы
- Существенно повысили безопасность

- Контроль над используемыми ресурсами и выполняемым кодом

## Минусы
- Увеличение сложности конфигурации

- Потребовалось много времени для настройки и рефакторинга
 
### Ссылка на PR
https://github.com/TourmalineCore/pelican-ui/pull/345
