# TDR - Test Decision Records - Кэширование и оптимизация картинок, nginx 

### Статус
На рассмотрении
## Контекст
У нас есть **3 бинарных параметра**:

- **Cache Images** = {Yes, No}
- **Optimization Images** = {Yes, No}
- **Nginx cache** = {Yes, No}

Всего комбинаций (по правилам комбинаторики): `2 * 2 * 2 (2^3) = 8`

1. Cache=**Yes**,  Optimization=**Yes**, Nginx=**Yes** 
2. Cache=**Yes**,  Optimization=**Yes**, Nginx=**No** 
3. Cache=**Yes**,  Optimization=**No**,  Nginx=**Yes** 
4. Cache=**Yes**,  Optimization=**No**,  Nginx=**No** 
5. Cache=**No**,   Optimization=**Yes**, Nginx=**Yes** 
6. Cache=**No**,   Optimization=**Yes**, Nginx=**No** 
7. Cache=**No**,   Optimization=**No**,  Nginx=**Yes** 
8. Cache=**No**,   Optimization=**No**,  Nginx=**No**

Наша задача - проверить максимальное покрытие сценариев минимальным количеством проверок
## Проблема

- Все комбинации проверять долго и дорого.
- Исключение некоторых комбинаций может привести к тому, что мы пропустим важный сценарий, где баг проявится именно на стыке параметров.
## Решение
В качестве оптимального компромисса применяем **Pairwise Testing** (техника попарного тестирования по тест-дизайну из ISTQB).

По правилу **ISTQB** - **I**nternational **S**oftware **T**esting **Q**ualifications **B**oard (Международный совет по квалификациям в области тестирования программного обеспечения), **дефекты чаще всего проявляются при сочетании двух факторов, а не трёх и более**

### 1. Покрываем каждую пару значений хотя бы 1 раз.
- **Пары Cache–Optimization:**
- (Yes, Yes), (Yes, No), (No, Yes), (No, No)
- **Пары Cache–Nginx:**
- (Yes, Yes), (Yes, No), (No, Yes), (No, No)
- **Пары Optimization–Nginx:**
- (Yes, Yes), (Yes, No), (No, Yes), (No, No)
Итого: **12 уникальных пар**
### 2. Строим минимальный набор сценариев, чтобы покрыть все пары
Ищем **минимальный набор**, в котором каждая пара встречается хотя бы 1 раз.
**Выбранные сценарии:**
```
1. Y, Y, Y   = покрывает (Cache=Y, Opt=Y), (Cache=Y, Nginx=Y), (Opt=Y, Nginx=Y)
2. Y, N, N   = покрывает (Cache=Y, Opt=N), (Cache=Y, Nginx=N), (Opt=N, Nginx=N)
3. N, Y, N   = покрывает (Cache=N, Opt=Y), (Cache=N, Nginx=N), (Opt=Y, Nginx=N) 
4. N, N, Y   = покрывает (Cache=N, Opt=N), (Cache=N, Nginx=Y), (Opt=N, Nginx=Y)
```
### 3. Проверяем, что все пары покрыты
- **Cache–Optimization:**
- (Y,Y) = Сценарий 1
- (Y,N) = Сценарий 2
- (N,Y) = Сценарий 3
- (N,N) = Сценарий 4 

- **Cache–Nginx:**
- (Y,Y) = Сценарий 1
- (Y,N) = Сценарий 2
- (N,N) = Сценарий 3
- (N,Y) = Сценарий 4 

- **Optimization–Nginx:**
 - (Y,Y) = Сценарий 1
- (N,N) = Сценарий 2
- (Y,N) = Сценарий 3
- (N,Y) = Сценарий 4
### 4. Итоговое покрытие:
1. Cache=**Yes**, Optimization=**Yes**, Nginx=**Yes** 
2. Cache=**Yes**, Optimization=**No**,  Nginx=**No** 
3. Cache=**No**,  Optimization=**Yes**, Nginx=**No** 
4. Cache=**No**,  Optimization=**No**,  Nginx=**Yes**`
Каждая пара значений встречается хотя бы один раз.
## Альтернативы
1. **Полное покрытие (8 сценариев)**
- Гарантия отсутствия пропусков  
	– Высокая стоимость
2. **Smoke-only (1–2 сценария)**
- Минимальная стоимость  
	– Слабое покрытие рисков
3. **Pairwise (4 сценария)** 
- Баланс покрытия и затрат
	- Применим в большинстве случаев производительных тестов
## Последствия и результаты
- Мы покрываем **все пары значений** опций, что соответствует **рекомендациям ISTQB**.
- Снижаем количество сценариев в 2 раза (с 8 до 4).
- Повышаем вероятность выявить баги при разумных затратах времени/ресурсов.
